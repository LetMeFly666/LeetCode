---
title: 面经 - 计网+数据库
date: 2025-02-18 11:44:54
tags: [其他, 面经, 计网, 计算机网络, 数据库, MySQL, Notes]
---

# 面经 - 计网+数据库

## 计算机网络

附[本科计网考试时的复习笔记](https://web.letmefly.xyz/Notes/ComputerNetwork/)，里面有很多ASCII图。

### TCP/IP网络模型

应用层：HTTP、FTP、Telnet、DNS、SMTP等

传输层：TCP(Transmission Control Protocol)、UDP

网络层：IP

网络接口层：网卡层次（封装上MAC地址）

### 三次握手

三次握手目的是**保证双方都有发送和接收的能力**

### 网络传输

交换机的端口不具备Mac地址。

在网络包传输的过程中，源IP和目标IP始终是不会变的（前提：没有使用NAT的网络），一直变化的是MAC地址，因为需要MAC地址在以太网内进行两个设备之间的包传输。

### 浏览器缓存

浏览器缓存分为强制缓存和协商缓存。

#### 强制缓存

只要浏览器判断缓存没有过期，就直接使用本地缓存（此时Status Code为200(from disk cache)）。决定是否使用缓存的主动性在于浏览器这边。

实现原理：利用HTTP响应头部的两个字段

1. `Cache-Control`，是一个相对时间；
2. `Expires`，是一个绝对时间。

二者同时存在的化，`Cache-Control`的优先级更高。（推荐）

#### 协商缓存

协商缓存是客户端和服务器协商之后通过协商结果判断是否使用本地缓存。若浏览器发现客户端不用加载新资源则返回`304`。实现方法有2：

1. 请求头中的`If-Modified-Since`和响应头中的`Last-Modified`。
2. 请求头中的`If-None-Match`和响应头中的`ETag`（每个资源一个id，修改既变）。

`ETag`优先级更高，`Last-Modified`只能做到秒级。

### HTTP/1.1、HTTP/2、HTTP/3

#### HTTP/1.1

HTTP/1.0每次请求都需要三次握手和四次挥手，HTTP/1.1支持长连接（握手，多次请求响应，挥手）。

+ 普通的长连接：每次请求得到响应后才能发起下次请求。
+ 管道网络传输：在收到响应前可以发送多个请求，但服务器必须按顺序响应。

**队头阻塞：** 若请求序列中某请求由于某种原因被阻塞，则后续排队的所有请求也都被阻塞。

管道网络传输解决了请求的队头阻塞问题，但没有解决响应的队头阻塞问题。并且，**HTTP/1.1的管道化技术默认没有开启！** 浏览器也基本上没有支持。

#### HTTP/2

支持了：头部压缩、二进制格式、并发传输、服务器主动推送资源

+ 头部压缩

    使用所谓的`HPACK`算法，客户端和服务器同时维护一张头部信息表，每个字段都会存入并生成索引，重复字段以后就只发送索引号了。

+ 二进制格式

    HTTP/1.1使用纯文本，`200`需要三个字节。HTTP/2头信息和数据体都是二进制格式(统称为帧，头信息帧Headers Frame和数据帧Data Frame)。

+ 并发传输

    多个Stream复用在一条TCP连接，每个Stream可以包含1个或多个Message(对应HTTP/1中的请求或响应)，Message包含一个或多个Frame(HTTP/2的最小单位，以二进制压缩格式存放HTTP/1中的内容(头部、包体))。

    每个Stream有Steram ID，接收端通过Stream ID有序组装成HTTP消息，因此Stream可以乱序发送和并发。

    但仍存在TCP层的队头阻塞问题，前一个字节未到达时后续接收到的字节只能放在内核缓冲区里。

+ 服务器推送

    客户端和服务器双方都可以建立Stream，客户端Steram ID为奇数，服务器为偶数。

    例如HTML需要CSS，直接由服务器推送给客户端吗，就不需要客户端再向服务器发送一次CSS的请求了。

#### HTTP/3

HTTP/3使用基于UDP的QUIC协议，通过应用层保证传输的可靠。只不过目前较新，很多网络设备无法识别QUIC。

+ 无队头阻塞

    QUIC类似HTTP/2的Stream，当某个流丢包时只会阻塞这个流。

+ 更快的连接

    QUIC协议并非与TLS分层，不像HTTP/1.1和HTTP/2需要三次TCP握手和三次TLS握手，只需要三次QUIC握手就能完成建立连接与密钥协商。

    第二次握手的时候，应用包数据可以和QUIC握手信息(连接信息+TLS信息)一起发送，达到0-rtt的效果。

+ 连接迁移

    基于TCP的HTTP协议通过四元组(源IP，源端口，目的ID，目的端口)确定一条TCP连接。网络切换时需要重新握手和挥手以及TCP慢启动，导致明显卡顿。

    QUIC通过连接ID标记通信的两个端点，只要仍有上下文信息哪怕IP改变也能“无缝”使用原连接。

## 数据库

### 索引

+ 按**数据结构**分类：B+tree索引、Hash索引、Full-text索引
+ 按**物理存储**分类：聚簇索引(主键索引)、二级索引(辅助索引)
+ 按**字段特性**分类：主键索引、唯一索引、普通索引、前缀索引
+ 按**字段个数**分类：单列索引、联合索引(复合索引)

#### 聚簇索引、非聚簇索引

MySQL5.5后默认使用InnoDB作为存储引擎。**建表**时聚簇索引：

1. 若有主键，默认使用主键作为聚簇索引
2. 若无主键，选第一列不包含NULL值的唯一列作为聚簇索引
3. 若上述两个都不存在，则InnoDB自动创建一个隐式的自增索引。

二者默认使用的都是B+树索引。

主键索引叶节点存放数据，二级索引叶节点存放主键值。**查询**二级索引时可能需要依据主键值在主键索引的B+Tree中查到数据，这个过程叫做**回表**。

若所查询信息在二级索引的叶节点中就能找到（例如就通过productNum查询productId），则无需再次查询主键索引，这个过程叫做**索引覆盖**。

#### 主键索引、唯一索引、普通索引、前缀索引

+ 主键索引：通常建表时创建，一张表只有一个，不允许有空值
+ 唯一索引：建立在UNIQUE字段上，一张表可以有多个，允许有空值
+ 普通索引：建立在普通字段上的索引，不要求字段未UNIQUE
+ 前缀索引：对字符类型字段的前几个字符建立的索引，可建在字段类型为char、varchar、binary、varbinary的列上

#### 单列索引、联合索引

单列索引：建立在单列上的索引。

联合索引：例如创建一个a, b字段的联合索引，则在B+树中，先依据a字段排序再依据b字段排序。

查询时存在**最左匹配原则**，需要先按a字段匹配再按b字段匹配`WHERE a = 1 AND b = 2`(a和b的顺序不重要，也可以`WHERE b = 2 AND a = 1`，反正查询优化器会优化)。

若只查询b字段，则联合索引将会失效（因为是a字段相同的前提下才会按b字段排序，b字段是全局无序的）。

联合索引的最左匹配原则，在遇到一些范围查询如`>`和`<`的时候就会停止匹配，后面字段无法用到联合索引。但对于`>=`、`<=`、`BETWEEN`、`like前缀匹配`的范围查询并不会立即停止：

+ 例如`WHERE a > 2 AND b = 1`，查询到`a > 2`的范围后，`b`字段不再有序
+ 但是`WHERE a >= 2 AND b = 1`，查询到`a = 2`时`b`字段仍会有序，`a > 2`的范围时`b`字段开始无序
+ 对于`WHERE a BETWEEN 2 AND 4 AND b = 1`，MySQL的`BETWEEN`是闭区间，相当于`a >= 2 AND a <= 4`
+ 对于`WHERE a LIKE 't%' AND b = 1`，查询到`a = 't'`时`b`字段仍有序，`a > 't'`（如`'tf'`时`b`字段总体上开始无序）

#### 索引下推

对于联合索引`(a, b)`，执行语句`select * from table where a > 1 and b = 2`的时候，只有`a`字段能用到索引。在B+树中搜索到`a > 1`的范围后，还需要看`b = 2`是否满足。

+ 在MySQL5.6之前，只能从主键值一个个回表，到主键索引上找出数据行并判断是否满足`b = 2`。
+ 在MySQL5.6引入了**索引下推优化**(index condition pushdown, ICP)，可以在联合索引遍历国策红肿对联合索引中包含的字段做判断，直接过滤掉不满足条件的记录，减少回表次数。

下推其实就是将部分上层(服务层)负责的事情交给了下层(引擎层)去处理。

### 事务

事务必须遵守4个特性（ACID）：

1. 原子性(Atomicity)：一个事务要么全部完成要么一点都不完成
2. 一致性(Consistency)：事务操作前后数据完整性（如A给B转账前后AB总金额不变）
3. 隔离性(Isolation)：多事务并发执行不会相互干扰
4. 持久性(Durability)：事务结束后对数据的修改是永久的，系统故障也不会丢失

InnoBD实现ACID：

1. 持久性：通过redo log(重做日志)来保证
2. 原子性：通过undo log(回滚日志)来保证
3. 隔离性：通过MVCC(多版本并发控制)来保证
4. 一致性：通过持久性+原子性+隔离性来保证

并行执行会带来的问题：

1. 脏读(dirty read)：一个事务读到另一个未提交事务修改过的数据
2. 不可重复度(non-repeatable read)：同一事务内多次读取前后结果不一致
3. 幻读(phantom read)：同一事务内多次查询同一范围数据返回行数不一致

#### 隔离级别

SQL标准提出了4种隔离级别，隔离级别越高性能越低：

+ 读未提交(read uncommitted): 这个事务还没被提交时就能被其他事务看到
+ 读已提交(read committed): 一个事务提交之后，它做的变更才能被其他事务看到
+ 可重复读(repeatable read): 一个事务执行过程中看到的数据跟事务启动时相同(MySQL InnoDB默认隔离级别)
+ 串行化(serializable): 对记录加锁，若多事务读写冲突则后访问的事务必须等前一个事务执行完成

不同隔离级别可能发生的现象：

```
+-----------+        +-----------+        +-----------+      +-----------+
|   脏读    |         |           |       |           |      |           |
|           |        |           |        |           |      |           |
| 不可重复读 |        | 不可重复读 |        |           |      |           |
|           |        |           |        |           |      |           |
|   幻读    |         |   幻读    |        |   幻读    |      |           |
+-----------+        +-----------+        +-----------+      +-----------+

   读未提交              读已提交             可重复读             串行化
```

MySQL支持4种级别的隔离，但与SQL标准中规定的有所出入。MySQL在可重复读隔离级别下就能**很大程度**避免幻读现象的发生。

#### MVCC的Read View

MySQL的InnoDB通过MVCC(Multi-Version Concurrency Control, 多版本并发控制)来实现对事务的隔离，并非加锁实现的。

InnoDB为每行数据添加了三个隐藏字段：

1. 最后一次插入/更新该行的事务id
2. 回滚指针，指向undo log（形成版本链）。若该行未被更新则为空
3. Row ID（该表未设置主键且聚簇索引为空时使用该id生成聚簇索引）

事务启动时，会创建read view，包括4个部分：

1. creator_trx_id：创建该read view的事务id
2. m_ids：创建read view时当前数据库中活跃且未提交的事务id列表
3. min_trx_id：m_ids中的最小值
4. max_trx_id：应该给下一个事务分配的事务id

这样，事务id查询一条记录时：

1. 若修改记录的事务id就是事务id，则该修改记录对该事务可见
2. 若修改记录的trx_id小于read view中的min_trx_id，则说明记录是在read view创建前已提交的事务生成的，该版本的记录对当前事务可见
3. 若trx_id大于等于max_trx_id，说明是该事务启动后的事务修改的，对该事务不可见，该事务开始遍历undo log中的下一条修改记录并进行相同的4种判断
4. 若$min\_trx\_id\leq trx\_id \lt max\_trx\_id$：若该事务id在m_ids列表则说明生成该版本记录事务依然活跃着仍未提交(该版本对当前事务不可见)；若该事务id不再m_ids中则说明生成该版本记录的事务已经被提交(该版本记录对当前事务可见)

可重复读和读提交的实现方式：

1. 可重复读：事务启动时创建一个read view
2. 读提交：每个select都会创建一个read view，这样就能读到其他事务已提交的数据了

# 小杂

### B端C端

似乎不是Browser和Client，而是Comsumer和Business（客户端/后台管理）

# End

> 原创不易，转载请经作者同意后附上[原文链接](https://blog.letmefly.xyz/2025/02/18/Other-Notes-Mianjing/)哦~