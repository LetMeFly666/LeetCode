---
title: 769.最多能完成排序的块
date: 2022-10-13 09:15:29
tags: [题解, LeetCode, 中等, 栈, 贪心, 数组, 排序, 单调栈]
categories: [题解, LeetCode]
---

# 【LetMeFly】769.最多能完成排序的块

力扣题目链接：[https://leetcode.cn/problems/max-chunks-to-make-sorted/](https://leetcode.cn/problems/max-chunks-to-make-sorted/)

<p>给定一个长度为 <code>n</code> 的整数数组 <code>arr</code> ，它表示在 <code>[0, n - 1]</code> 范围内的整数的排列。</p>

<p>我们将 <code>arr</code> 分割成若干 <strong>块</strong> (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p>

<p>返回数组能分成的最多块数量。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> arr = [4,3,2,1,0]
<strong>输出:</strong> 1
<strong>解释:</strong>
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> arr = [1,0,2,3,4]
<strong>输出:</strong> 4
<strong>解释:</strong>
我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。
然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
	<li><code>n == arr.length</code></li>
	<li><code>1 &lt;= n &lt;= 10</code></li>
	<li><code>0 &lt;= arr[i] &lt; n</code></li>
	<li><code>arr</code>&nbsp;中每个元素都 <strong>不同</strong></li>
</ul>


    
## 方法一：用数组记录是否该出现的都出现过

题目说“把每个块分别排序后组合到一起，效果等价于对整个数组排序”。同时又说“这个数组是从$0$到$n-1$的一个排列”

什么意思呢？也就是说如果将某一段划分为了“一个块”，那么这一段一定包含排序后对应位置应有的所有元素。

比如原始数组是

```
1 0 4 2 3 5
```

排序后应为

```
0 1 2 3 4 5
```

那么我们就可以将原始数组分成三部分：

```
[1 0] [4 2 3] [5]
```

对应排序后的

```
[0 1] [2 3 4] [5]
```

这样，“第一块”中元素为```[1 0]```，而排序后前两个元素应该是```[0 1]```。```[1 0]```中既包含```0```又包含```1```，因此```[1 0]```可以划分为“一块”

同理，```[4 2 3]```也可以划分为“一块”，因为它对应着```[2 3 4]```；```[5]```可以划分为一块，因为它对应着```[5]```。

最终答案就是```3```块。

**怎么编程实现呢？**

我们可以从前往后遍历原始数组，如果原始数组的前```t```个元素包含```[0, t - 1]```，那么就可以将前```t```个元素划分为“一块”

同时，每次遇到“前```t```个元素包含```[0, t - 1]```”，就能再划分出“一块”

还以```1 0 4 2 3 5```举例：

从前到后遍历上述数组：

+ 前$1$个元素为```[1]```，不包含```[0]```，不能划分为一块，当前答案为$0$
+ 前$2$个元素为```[1 0]```，包含```[0 1]```，能划分为一块，当前答案为$1$
+ 前$3$个元素为```[1 0 4]```，不包含```[0 1 2]```，不能划分为一块，当前答案为$1$
+ 前$4$个元素为```[1 0 4 2]```，不包含```[0 1 2 3]```，不能划分为一块，当前答案为$1$
+ 前$5$个元素为```[1 0 4 2 3]```，包含```[0 1 2 3 4]```，能**再**划分为一块，当前答案为$2$（除了```[1 0]```能单独划分为一块外，```[4 2 3]```也能单独划分为一块）
+ 前$6$个元素为```[1 0 4 2 3 5]```，包含```[0 1 2 3 4 5]```，能**再**划分为一块，当前答案为$3$

因此答案为$3$

我们可以使用一个数组$bin$，其中$bin[i]$表示$i$有没有出现过

接下来遍历数组，遍历到下标$i$时，就看$bin[0]\sim bin[i]$是否都被标记过。

如果是，则答案+1

+ 时间复杂度$O(n^2)$，其中$n$是原始数组长度
+ 空间复杂度$O(N)$，其中$N$是原始数组的最大长度，本题中$N=10$

### AC代码

#### C++

```cpp
class Solution {
private:
    inline bool allAppeared(bool* bin, int to) {
        for (int i = 0; i <= to; i++)
            if (!bin[i])
                return false;
        return true;
    }
public:
    int maxChunksToSorted(vector<int>& arr) {
        bool bin[10] = {false};
        int ans = 0;
        for (int i = 0; i < arr.size(); i++) {
            bin[arr[i]] = true;
            if (allAppeared(bin, i))
                ans++;
        }
        return ans;
    }
};
```

## 方法二：只记录所有出现过的元素中的最大值

承接方法一，方法一中，我们判断$0\sim i$的元素是否都出现过，使用的方法是“开辟bin数组记录出现过的元素，再遍历确认是否每个元素都出现过”

有没有方法可以对其进行优化呢？

不难发现，我们关注的问题是，是否**从0到i - 1**都出现过

那么，我们记录一下所有出现过的元素的最大值不就好了么？

如果前$t$个出现过的数的最大值是$t-1$，那么就说明前$t$个数从$0$到$t-1$各出现了一遍。

这得益于：

1. 每个数各不相同，也就是说每个数最多出现一次
2. 每个数都$\geq0$

这样，一是不需要开辟长度为10的数组空间了，二是可以迅速确定出$0\sim i - 1$是否每个数都出现了一次。

+ 时间复杂度$O(n)$，其中$n$是原始数组长度
+ 空间复杂度$O(1)$

### AC代码

#### C++

```cpp
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        int M = 0;
        int ans = 0;
        for (int i = 0; i < arr.size(); i++) {
            M = max(M, arr[i]);
            ans += i == M;
        }
        return ans;
    }
};
```

> 同步发文于CSDN，原创不易，转载请附上[原文链接](https://blog.letmefly.xyz/2022/10/13/LeetCode%200769.%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/)哦~
> Tisfy：[https://letmefly.blog.csdn.net/article/details/127295302](https://letmefly.blog.csdn.net/article/details/127295302)
