---
title: 901.股票价格跨度
date: 2022-10-21 20:12:24
tags: [题解, LeetCode, 中等, 栈, 设计, 数据流, 单调栈]
---

# 【LetMeFly】901.股票价格跨度

力扣题目链接：[https://leetcode.cn/problems/online-stock-span/](https://leetcode.cn/problems/online-stock-span/)

<p>编写一个 <code>StockSpanner</code> 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。</p>

<p>今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p>

<p>例如，如果未来7天股票的价格是 <code>[100, 80, 60, 70, 60, 75, 85]</code>，那么股票跨度将是 <code>[1, 1, 1, 2, 1, 4, 6]</code>。</p>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<pre><strong>输入：</strong>[&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]
<strong>输出：</strong>[null,1,1,1,2,1,4,6]
<strong>解释：</strong>
首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。

注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
	<li>调用&nbsp;<code>StockSpanner.next(int price)</code>&nbsp;时，将有&nbsp;<code>1 &lt;= price &lt;= 10^5</code>。</li>
	<li>每个测试用例最多可以调用&nbsp; <code>10000</code> 次 <code>StockSpanner.next</code>。</li>
	<li>在所有测试用例中，最多调用&nbsp;<code>150000</code>&nbsp;次&nbsp;<code>StockSpanner.next</code>。</li>
	<li>此问题的总时间限制减少了 50%。</li>
</ol>


    
## 方法一：单调栈

建立一个单调栈，其中数据类型```<价格, 连续天数>```

当新元素价格大于栈顶价格时，不断出栈并累加连续天数，最终天数即为答案。

初始值是一个“无穷大的价格”

以样例一```[100, 80, 60, 70, 60, 75, 85]```为例：

```
[ (2147483647, 6666666)
              这个数随意
```

**第一个数100：**

构造```(100, 1)```

```100```小于栈顶元素```2147483647```

```(100, 1)```入栈，并返回```1```

```
[ (2147483647, 6666666), (100, 1)
```

**第二个数80：**

构造```(80, 1)```

```80```小于栈顶元素```100```

```(80, 1)```入栈，并返回```1```

```
[ (2147483647, 6666666), (100, 1), (80, 1)
```


**第三个数60：**

构造```(60, 1)```

```60```小于栈顶元素```80```

```(60, 1)```入栈，并返回```1```

```
[ (2147483647, 6666666), (100, 1), (80, 1), (60, 1)
```

**第四个数70：**

构造```(70, 1)```

```70```大于栈顶元素```60```

```(60, 1)```出栈，```(70, 1)```的连续天数加上```(60, 1)```的```1```变成```(70, 2)```

```
[ (2147483647, 6666666), (100, 1), (80, 1)
```

继续和栈顶元素比较

```70```小于栈顶元素```80```

```(70, 2)```入栈，并返回```2```

```
[ (2147483647, 6666666), (100, 1), (80, 1), (70, 2)
```

**第五个数60：**

构造```(60, 1)```

```60```小于栈顶元素```70```

```(60, 1)```入栈，并返回```1```

```
[ (2147483647, 6666666), (100, 1), (80, 1), (70, 2), (60, 1)
```

**第六个数75：**

构造```(75, 1)```

```75```大于栈顶元素```60```

```(60, 1)```出栈，```(75, 1)```的连续天数加上```(60, 1)```的```1```变成```(75, 2)```

```
[ (2147483647, 6666666), (100, 1), (80, 1), (70, 2)
```

继续和栈顶元素比较

```75```大于栈顶元素```70```

```(70, 2)```出栈，```(75, 2)```的连续天数加上```(70, 2)```的```2```变成```(75, 4)```

```
[ (2147483647, 6666666), (100, 1), (80, 1)
```

继续和栈顶元素比较

```75```小于栈顶元素```80```

```(75, 4)```入栈，并返回```4```

```
[ (2147483647, 6666666), (100, 1), (80, 1), (75, 4)
```

**第七个数85：**

构造```(85, 1)```

```85```大于栈顶元素```75```

```(75, 4)```出栈，```(85, 1)```的连续天数加上```(75, 4)```的```4```变成```(85, 5)```

```
[ (2147483647, 6666666), (100, 1), (80, 1)
```

继续和栈顶元素比较

```85```大于栈顶元素```80```

```(80, 1)```出栈，```(85, 5)```的连续天数加上```(80, 1)```的```1```变成```(85, 6)```

```
[ (2147483647, 6666666), (100, 1)
```

继续和栈顶元素比较

```85```小于栈顶元素```1000```

```(85, 6)```入栈，并返回```6```

```
[ (2147483647, 6666666), (100, 1), (85, 6)
```

**任务完成。**

+ 时间复杂度$O(N)$，其中一共调用了$N$次```next()```函数，平均单次时间复杂度$O(1)$
+ 空间复杂度$O(N)$

### AC代码

#### C++

```cpp
typedef pair<int, int> pii;  // <price, 连续>
class StockSpanner {
private:
    stack<pii> st;
public:
    StockSpanner() {
        st.push({INT_MAX, 666});
    }
    
    int next(int price) {
        int cnt = 1;
        while (price >= st.top().first) {
            cnt += st.top().second;
            st.pop();
        }
        st.push({price, cnt});
        return cnt;
    }
};
```

#### Python

```python
class StockSpanner:

    def __init__(self):
        self.st = []  # <price, cnt>


    def next(self, price: int) -> int:
        ans = 1
        while len(self.st) and self.st[-1][0] <= price:
            ans += self.st[-1][1]
            self.st.pop()
        self.st.append([price, ans])
        return ans
```

> 同步发文于CSDN，原创不易，转载请附上[原文链接](https://blog.letmefly.xyz/2022/10/21/LeetCode%200901.%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/)哦~
> Tisfy：[https://letmefly.blog.csdn.net/article/details/127453430](https://letmefly.blog.csdn.net/article/details/127453430)
