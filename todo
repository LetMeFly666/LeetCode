# 记录windows凭据问题
# failed to migrate config: cowardly refusing to continue with multi account migration: couldn't migrate oauth token for "github.com": Not enough memory resources are available to process this command.
# failed to move active token in keyring: Not enough memory resources are available to process this command.
# rm 多余凭据
# gh auth refresh -s project

# https://github.com/desktop/desktop/issues/15217

# 记录iphone快捷指令 自动化 当到达某位置时触发

# move beautify.sh to github repo/gist

# record: py proxy
# Python\Lib\site-packages\requests\utils.py
# F:\OtherApps\Program\Python\Python\Lib\urllib\request.py
"""
2689行的proxies['https'] = 'https://%s' % proxyServer
修改为了
if '127.0.0.1' in proxyServer or 'localhost' in proxyServer:
    proxies['https'] = 'http://%s' % proxyServer
else:
    proxies['https'] = 'https://%s' % proxyServer
"""

import re
import os

def should_bypass_proxies(a, no_proxy):
    return False

def getproxies_registry():
    """Return a dictionary of scheme -> proxy server URL mappings.

    Win32 uses the registry to store proxies.

    """
    proxies = {}
    try:
        import winreg
    except ImportError:
        # Std module, so should be around - but you never know!
        return proxies
    try:
        internetSettings = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
            r'Software\Microsoft\Windows\CurrentVersion\Internet Settings')
        proxyEnable = winreg.QueryValueEx(internetSettings,
                                            'ProxyEnable')[0]
        if proxyEnable:
            # Returned as Unicode but problems if not converted to ASCII
            proxyServer = str(winreg.QueryValueEx(internetSettings,
                                                    'ProxyServer')[0])
            if '=' in proxyServer:
                # Per-protocol settings
                for p in proxyServer.split(';'):
                    protocol, address = p.split('=', 1)
                    # See if address has a type:// prefix
                    if not re.match('(?:[^/:]+)://', address):
                        address = '%s://%s' % (protocol, address)
                    proxies[protocol] = address
            else:
                # Use one setting for all protocols
                if proxyServer[:5] == 'http:':
                    proxies['http'] = proxyServer
                else:
                    proxies['http'] = 'http://%s' % proxyServer
                    proxies['https'] = 'https://%s' % proxyServer
                    proxies['ftp'] = 'ftp://%s' % proxyServer
        internetSettings.Close()
    except (OSError, ValueError, TypeError):
        # Either registry key not found etc, or the value in an
        # unexpected format.
        # proxies already set up to be empty so nothing to do
        pass
    return proxies

# Proxy handling
def getproxies_environment():
    """Return a dictionary of scheme -> proxy server URL mappings.

    Scan the environment for variables named <scheme>_proxy;
    this seems to be the standard convention.  If you need a
    different way, you can pass a proxies dictionary to the
    [Fancy]URLopener constructor.

    """
    proxies = {}
    # in order to prefer lowercase variables, process environment in
    # two passes: first matches any, second pass matches lowercase only
    for name, value in os.environ.items():
        name = name.lower()
        if value and name[-6:] == '_proxy':
            proxies[name[:-6]] = value
    # CVE-2016-1000110 - If we are running as CGI script, forget HTTP_PROXY
    # (non-all-lowercase) as it may be set from the web server by a "Proxy:"
    # header from the client
    # If "proxy" is lowercase, it will still be used thanks to the next block
    if 'REQUEST_METHOD' in os.environ:
        proxies.pop('http', None)
    for name, value in os.environ.items():
        if name[-6:] == '_proxy':
            name = name.lower()
            if value:
                proxies[name[:-6]] = value
            else:
                proxies.pop(name[:-6], None)
    return proxies


def getproxies():
    """Return a dictionary of scheme -> proxy server URL mappings.

    Returns settings gathered from the environment, if specified,
    or the registry.

    """
    return getproxies_environment() or getproxies_registry()

def get_environ_proxies(url, no_proxy=None):
    """
    Return a dict of environment proxies.

    :rtype: dict
    """
    if should_bypass_proxies(url, no_proxy=no_proxy):
        return {}
    else:
        return getproxies()
    
print(get_environ_proxies("https://letmefly.xyz"))