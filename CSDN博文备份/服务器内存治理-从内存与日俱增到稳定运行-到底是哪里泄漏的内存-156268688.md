<hr /> <br><h3><a id="title_____%0Atitle_en_From_Memory_Creep_to_Stability_A_Deep_Dive_into_Server_Memory_Leaks%0Adate_20251225_125316%0Atags___Linux%0Acategories__2"></a>title: 服务器内存治理 - 从内存与日俱增到稳定运行 - 到底是哪里泄漏的内存<br /> title_en: “From Memory Creep to Stability: A Deep Dive into Server Memory Leaks”<br /> date: 2025-12-25 12:53:16<br /> tags: [其他, 服务器, Linux]<br /> categories: [技术思考]</h3> <br><h2><a id="_____9"></a>服务器内存治理 - 从内存与日俱增到稳定运行 - 到底是哪里泄漏的内存</h2> <br><blockquote> <br> <p>From Memory Creep to Stability: A Deep Dive into Server Memory Leaks</p> <br></blockquote> <br><h3><a id="_13"></a>背景</h3> <br><p>吾有一小服务器，大二时写的服务一直在上面运行。后续增增改改，转眼间五年过去。</p> <br><p>之前服务器可能平均大约能运行个一百五十天，然后内存就会疯狂报警，再过2天左右会因内存占满而死机。</p> <br><p>最近这种现象开始变得频繁，十来天甚至五天都可能遇到一次。是时候治理一下了。</p> <br><h3><a id="_21"></a>内存监控</h3> <br><p>所有服务刚启动时，服务器资源总占用不到1G，光服务运行缓存之类的正常不至于增到内存占满，大概是存在着一些内存泄漏或者死进程。</p> <br><p>于是思路是写个脚本监控下悄悄增加的内存有哪些。</p> <br><pre><code class="prism language-bash"><span class="token assign-left variable">TS</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +<span class="token string">"%Y-%m-%d %H:%M:%S"</span><span class="token variable">)</span></span><br><span class="token assign-left variable">OUT</span><span class="token operator">=</span><span class="token string">"/var/log/let_proc_snapshot.log"</span><br><br><span class="token builtin class-name">echo</span> <span class="token string">"===== <span class="token variable">$TS</span> ====="</span> <span class="token operator">>></span> <span class="token string">"<span class="token variable">$OUT</span>"</span><br><span class="token function">ps</span> -eo pid,ppid,user,lstart,etimes,rss,comm,args --sort<span class="token operator">=</span>-rss,ppid,pid <span class="token operator">>></span> <span class="token string">"<span class="token variable">$OUT</span>"</span><br><span class="token builtin class-name">echo</span> <span class="token operator">>></span> <span class="token string">"<span class="token variable">$OUT</span>"</span><br></code></pre> <br><p>保存为<code>WatchMem.sh</code>，然后</p> <br><pre><code class="prism language-bash"><span class="token function">chmod</span> +x WatchMem.sh<br></code></pre> <br><p>设置为定时任务，1分钟采样一次（其实不用这么频繁就行）</p> <br><pre><code class="prism language-bash"><span class="token function">crontab</span> -e<br></code></pre> <br><p>添加一行：</p> <br><pre><code>* * * * * /bin/bash -c '/xx/TFpath/WatchMem.sh'<br></code></pre> <br><p>会得到类似这样的日志：</p> <br><pre><code class="prism language-log">    PID    PPID USER                      STARTED ELAPSED   RSS COMMAND         COMMAND<br>   2020       1 mysql    Fri Dec 19 13:37:47 2025  250527 495552 mysqld         /usr/libexec/mysqld --basedir=/usr<br></code></pre> <br><p>不得不说服务器这次挺给力的，刚运行不到48h内存就增加了200M，是时候分析下了。</p> <br><h3><a id="_63"></a>日志采样</h3> <br><p>决定直接丢给ChatGPT让帮忙分析一波，结果30多MB的纯文本数据过大，无法上传。</p> <br><p>于是写了个日志采样脚本，只保留分钟数是5的倍数的日志：</p> <br><pre><code class="prism language-python"><span class="token keyword">import</span> re<br><span class="token keyword">from</span> typing <span class="token keyword">import</span> Optional<br><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<br><br>INPUT_FILE <span class="token operator">=</span> <span class="token string">"xx/let_proc_snapshot.log"</span><br>OUTPUT_FILE <span class="token operator">=</span> <span class="token string">"xx/proc_snapshot_5min.log"</span><br><br><span class="token comment"># 匹配头部时间行</span><br>HEADER_RE <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r"^===== (.+) =====$"</span><span class="token punctuation">)</span><br><br><span class="token keyword">def</span> <span class="token function">parse_time</span><span class="token punctuation">(</span>line<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>datetime<span class="token punctuation">]</span><span class="token punctuation">:</span><br>    m <span class="token operator">=</span> HEADER_RE<span class="token punctuation">.</span><span class="token keyword">match</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token keyword">if</span> <span class="token keyword">not</span> m<span class="token punctuation">:</span><br>        <span class="token keyword">return</span> <span class="token boolean">None</span><br>    <span class="token keyword">return</span> datetime<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"%Y-%m-%d %H:%M:%S"</span><span class="token punctuation">)</span><br><br><span class="token keyword">def</span> <span class="token function">should_keep</span><span class="token punctuation">(</span>ts<span class="token punctuation">:</span> datetime<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span><br>    <span class="token keyword">return</span> ts<span class="token punctuation">.</span>minute <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><br><br><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>INPUT_FILE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fin<span class="token punctuation">,</span> \<br>         <span class="token builtin">open</span><span class="token punctuation">(</span>OUTPUT_FILE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fout<span class="token punctuation">:</span><br><br>        block_lines <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><br>        block_time <span class="token operator">=</span> <span class="token boolean">None</span><br><br>        <span class="token keyword">for</span> line <span class="token keyword">in</span> fin<span class="token punctuation">:</span><br>            ts <span class="token operator">=</span> parse_time<span class="token punctuation">(</span>line<span class="token punctuation">)</span><br>            <span class="token keyword">if</span> ts<span class="token punctuation">:</span><br>                <span class="token comment"># 新 block 开始，先处理上一个</span><br>                <span class="token keyword">if</span> block_time <span class="token keyword">and</span> should_keep<span class="token punctuation">(</span>block_time<span class="token punctuation">)</span><span class="token punctuation">:</span><br>                    fout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>block_lines<span class="token punctuation">)</span><br><br>                block_lines <span class="token operator">=</span> <span class="token punctuation">[</span>line<span class="token punctuation">]</span><br>                block_time <span class="token operator">=</span> ts<br>            <span class="token keyword">else</span><span class="token punctuation">:</span><br>                block_lines<span class="token punctuation">.</span>append<span class="token punctuation">(</span>line<span class="token punctuation">)</span><br><br>        <span class="token comment"># 文件结束，别忘了最后一个 block</span><br>        <span class="token keyword">if</span> block_time <span class="token keyword">and</span> should_keep<span class="token punctuation">(</span>block_time<span class="token punctuation">)</span><span class="token punctuation">:</span><br>            fout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>block_lines<span class="token punctuation">)</span><br><br>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Resample done: </span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>OUTPUT_FILE<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span><br><br><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span><br>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><br></code></pre> <br><p>文件体积变成了6M。</p> <br><h3><a id="_120"></a>找到“元凶”</h3> <br><p>可能是AI的节能策略，GPT默认并没有分析日志文件，而是直接开始“猜测”可能原因。经过一轮对话的周折，AI一下就分析出来了。</p> <br><p>进程中多了好几个<code>python manage.py crontab run xxxxx</code>，诶，说明很多定时任务没有退出。</p> <br><p>一个python定时任务大约占用小50M内存，几个就占200M了。回到django目录运行<code>python manage.py crontab show</code>得知这个定时任务是我本科时候担任学校ACM集训队队长时，写的企业微信比赛提醒机器人。</p> <br><p>脚本定时爬取比赛数据并在比赛即将开始时推送，比赛范围包括Codeforces、AtCoder等。</p> <br><p>本科毕业已经几年过去，不知当时的机器人是否还有人在使用。但一看就能知道大概是外国这些网站HTTP请求阻塞了。</p> <br><h3><a id="_132"></a>解决“元凶”</h3> <br><p>先杀掉所有被卡死的进程：</p> <br><pre><code class="prism language-bash"><span class="token function">pkill</span> -f <span class="token string">"manage.py crontab run"</span><br></code></pre> <br><p>然后设置crontab最大执行时间：</p> <br><pre><code class="prism language-bash"><span class="token function">crontab</span> -e<br></code></pre> <br><p>在<code>*/5 * * * * timeout 60 python crontab run xxx</code>命令前面加个<code>timeout 60</code>变成<code>*/5 * * * * timeout 60 python crontab run xxx</code>，这样超时也会自动退出了。</p> <br><h3><a id="_148"></a>不看不知道，一看吓一跳</h3> <br><p>看了看才知道，服务器中依然使用的几年前的命令，不适合用在开发环境的：</p> <br><pre><code class="prism language-bash">python manage.py runserver<br></code></pre> <br><p>赶紧改成了：</p> <br><pre><code class="prism language-bash"><span class="token comment"># pip install gunicorn</span><br>gunicorn ProjectName.wsgi:application --workers <span class="token number">2</span> --bind <span class="token number">127.0</span>.0.1:8000 --max-requests <span class="token number">1000</span> --max-requests-jitter <span class="token number">100</span><br></code></pre> <br><h3><a id="End_163"></a>End</h3> <br><p>至此，本次治理暂时完结。</p> <br><center><br> <font size="6px" face="Ink Free">The Real End, Thanks!</font><br></center> <br><blockquote> <br> <p>同步发文于<a href="https://letmefly.blog.csdn.net/article/details/156268688" rel="nofollow">CSDN</a>和我的<a href="https://blog.letmefly.xyz/" rel="nofollow">个人博客</a>，原创不易，转载经作者同意后请附上<a href="https://blog.letmefly.xyz/2025/12/25/Other-Server-MemoryGovernance/" rel="nofollow">原文链接</a>哦~</p> <br> <p>千篇源码题解<a href="https://github.com/LetMeFly666/LeetCode">已开源</a></p> <br></blockquote>