<hr /> <br><h3><a id="title_Github__PR%0Adate_20250206_110947%0Atags__Git_Github_2"></a>title: Github - 记录一次对“不小心包含了密码的PR”的修复<br /> date: 2025-02-06 11:09:47<br /> tags: [其他, Git, Github]</h3> <br><h2><a id="Github__PR_7"></a>Github - 记录一次对“不小心包含了密码的PR”的修复</h2> <br><h3><a id="_9"></a>前言</h3> <br><p>和好朋友一起开发一个字节跳动青训营<a href="https://github.com/LetMeFly666/douyinec">抖音电商后端(now private)</a>的项目，某大佬不小心把本地一密码commit上去并提了PR。</p> <br><p>PR一旦发出则无法被删除，且其包含的commit也能被所有能看到这个仓库的人看到。虽然是本地一密码，泄露了也不是很严重，但最好还是隐藏一下这个信息。</p> <br><h3><a id="_16"></a>思路</h3> <br><p>思路为：</p> <br><ol><li><a href="#%E5%BC%BA%E5%88%B6%E9%87%8D%E5%86%99%E6%9C%AC%E6%AC%A1pr%E7%9A%84commits" rel="nofollow">强制重写本次PR的commits</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%AF%86%E7%A0%81%E6%B3%84%E9%9C%B2sha%E7%9A%84%E5%87%BA%E7%8E%B0%E4%BD%8D%E7%BD%AE" rel="nofollow">删除评论、Action等所有可能带有“密码泄露sha”的记录</a></li><li><a href="#%E5%8A%A0%E5%BC%BA%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83" rel="nofollow">加强安全防范</a></li></ol> <br><p>其他人无法得知密码泄露的那次commit的sha，也就无法找到泄露的密码。</p> <br><h3><a id="_26"></a>实操</h3> <br><h4><a id="PRcommits_28"></a>强制重写本次PR的commits</h4> <br><p>其实PR中包含“密码commit”不用惊慌，重写包含密码commit的源分支，与协作者沟通并强制push即可。</p> <br><p>但是由于误操等原因，PR被close并且源分支被删除了。于是思路变成了：<code>恢复源分支</code> -> <code>重新打开PR</code> -> <code>强制重写源分支</code>。</p> <br><p>这里需要补充一丢丢Github PR的知识：</p> <br><blockquote> <br> <p>Pull Request(PR)通常是开发者想将一个分支(源分支)合并到另一个分支(目标分支)从而提交的更改请求。</p> <br> <p><code>a</code>分支对<code>b</code>分支的PR在同一时间只能存在一个(关闭的PR除外)，提出PR后合并之前任何对<code>a</code>分支的更改都将同步反映到PR上，直到PR被合并或关闭为止。</p> <br> <p>一个PR被强制关闭后，想要重新打开的前提是<code>a</code>分支依然存在并且还是提PR时候的<code>a</code>分支（另创分支并起名为<code>a</code>、被关闭PR中的commit强制重写过的<code>a</code>分支不算）。</p> <br></blockquote> <br><p>问题是远端(Github)<code>a</code>分支被删除了，还没拉取到本地过，还能恢复这个<code>a</code>分支到<code>PR</code>关闭时的状态（或在此状态上新增了commit的状态）吗？当然可以，这就是Git：</p> <br><pre><code class="prism language-bash"><span class="token function">git</span> fetch origin pull/<span class="token operator"><</span>PR编号<span class="token operator">></span>/head:<span class="token operator"><</span>分支名<span class="token operator">></span><br><span class="token function">git</span> switch <span class="token operator"><</span>分支名<span class="token operator">></span><br></code></pre> <br><p>之后就可以push到远端，重新开启PR，本地回滚，隐匿密码，重新commit，强制push到远端，关闭PR并删除远端分支(可选)了。</p> <br><pre><code class="prism language-bash"><span class="token function">git</span> push --set-upstream origin <span class="token operator"><</span>分支名<span class="token operator">></span><br>gh <span class="token function">pr</span> reopen <span class="token number">30</span><br><span class="token function">git</span> reset HEAD^<br><span class="token function">vim</span> config.toml<br><span class="token function">git</span> <span class="token function">add</span> xxx<br><span class="token function">git</span> commit <span class="token parameter variable">-s</span> <span class="token parameter variable">-m</span> <span class="token string">"xxx"</span><br><span class="token function">git</span> push <span class="token parameter variable">--force</span><br>gh <span class="token function">pr</span> close <span class="token number">30</span> <span class="token parameter variable">-c</span> <span class="token string">"历史已重写"</span><br><span class="token function">git</span> push origin <span class="token parameter variable">--delete</span> <span class="token operator"><</span>分支名<span class="token operator">></span><br></code></pre> <br><h4><a id="sha_63"></a>删除“密码泄露sha”的出现位置</h4> <br><p>虽然带有密码的commit被删除了，不会被合并到各个分支中了，变成了“游离”的commit。</p> <br><p>但是其他人知道这个commit的sha的话，还是能够<a href="https://github.com/LetMeFly666/douyinec/commit/xxxxxx_commitHash_sha">访问</a>。</p> <br><p>也许Github服务器上什么时候会在<code>git gc</code>的时候清除这个commit，但暂未寻找相关文档，是否会发生以及发生具体时间不详。</p> <br><p>但是所幸，commit的message以及action的记录都是可以强制删除的，注意GitGuardian等即使修改了历史评论，但github上仍然可以看到历史评论，记得删除历史评论。</p> <br><h4><a id="_73"></a>加强安全防范</h4> <br><p>最好的办法就是在本地仓库创建一个预提交的<a href="https://github.com/pre-commit/pre-commit">钩子</a>，但是需要每个Collaborator自己在本地分别安装，最少也要执行一下<code>git config --local core.hooksPath xxx钩子文件</code>命令。</p> <br><p>然后提交的时候最好不要<code>git add .</code>或<code>git add *</code>之类的，最好一个一个看看。</p> <br><p>其次就是使用一些密码泄露检测工具，放在<a href="#end" rel="nofollow">文章结尾</a>部分了。</p> <br><p>好用的密码泄露检测工具可以一旦密码泄露立即报警，若不慎泄露则需要<strong>和其他成员沟通并</strong>强制push，必要的话可能需要更改密码。</p> <br><h3><a id="End_83"></a>End</h3> <br><p>推荐一个第三方秘密检测工具<a href="https://github.com/apps/gitguardian">GitGuardian</a>，检测功能强大，能根据代码语境检测。</p> <br><p>自荐一个简单的密码检测Bot<a href="https://github.com/marketplace/actions/let-secret-monitor">Let Secret Monitor</a>，支持自定义密钥信息，普通的commit在push后也会触发检测。</p> <br><center> <br> <font size="6px" face="Ink Free">The Real End, Thanks!</font> <br></center> <br><blockquote> <br> <p>原创不易，转载经作者同意后请附上<a href="https://blog.letmefly.xyz/2025/02/06/Other-Github-PrCredentialLeakFix/" rel="nofollow">原文链接</a>哦~<br /> Tisfy：<a href="https://letmefly.blog.csdn.net/article/details/145469338" rel="nofollow">https://letmefly.blog.csdn.net/article/details/145469338</a></p> <br></blockquote>