<h2><a id="LetMeFly955_IIOmn___1"></a>【LetMeFly】955.删列造序 II：模拟（O(mn)） + 提前退出</h2> <br><p>力扣题目链接：<a href="https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/" rel="nofollow">https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/</a></p> <br><p>给定由 <code>n</code> 个字符串组成的数组 <code>strs</code>，其中每个字符串长度相等。</p> <br><p>选取一个删除索引序列，对于 <code>strs</code> 中的每个字符串，删除对应每个索引处的字符。</p> <br><p>比如，有 <code>strs = ["abcdef", "uvwxyz"]</code>，删除索引序列 <code>{0, 2, 3}</code>，删除后 <code>strs</code> 为<code>["bef", "vyz"]</code>。</p> <br><p>假设，我们选择了一组删除索引 <code>answer</code>，那么在执行删除操作之后，最终得到的数组的元素是按 <strong>字典序</strong>（<code>strs[0] <= strs[1] <= strs[2] ... <= strs[n - 1]</code>）排列的，然后请你返回 <code>answer.length</code> 的最小可能值。</p> <br><p> </p> <br><ol></ol> <br><p><strong>示例 1：</strong></p> <br><pre><strong>输入：</strong>strs = ["ca","bb","ac"]<br><strong>输出：</strong>1<br><strong>解释： </strong><br>删除第一列后，strs = ["a", "b", "c"]。<br>现在 strs 中元素是按字典排列的 (即，strs[0] <= strs[1] <= strs[2])。<br>我们至少需要进行 1 次删除，因为最初 strs 不是按字典序排列的，所以答案是 1。<br></pre> <br><p><strong>示例 2：</strong></p> <br><pre><strong>输入：</strong>strs = ["xc","yb","za"]<br><strong>输出：</strong>0<br><strong>解释：</strong><br>strs 的列已经是按字典序排列了，所以我们不需要删除任何东西。<br>注意 strs 的行不需要按字典序排列。<br>也就是说，strs[0][0] <= strs[0][1] <= ... 不一定成立。<br></pre> <br><p><strong>示例 3：</strong></p> <br><pre><strong>输入：</strong>strs = ["zyx","wvu","tsr"]<br><strong>输出：</strong>3<br><strong>解释：</strong><br>我们必须删掉每一列。<br></pre> <br><p> </p> <br><p><strong>提示：</strong></p> <br><ul><li><code>n == strs.length</code></li><li><code>1 <= n <= 100</code></li><li><code>1 <= strs[i].length <= 100</code></li><li><code>strs[i]</code> 由小写英文字母组成</li></ul> <br><h3><a id="_62"></a>解题方法：模拟</h3> <br><h4><a id="_64"></a>解题思路</h4> <br><p>先来理解题意：</p> <br><blockquote> <br> <p>删除尽可能少的列，使得上面一行字符串的字典序不大于下面一行。</p> <br></blockquote> <br><p>什么时候上面(a)字典序不大于下面一行(b)呢？</p> <br><blockquote> <br> <p>从前往后遍历两个字符串：</p> <br> <ul><li>一旦遇到<code>a[i] > b[i]</code>，直接不符</li><li>一旦遇到<code>a[i] > b[i]</code>，直接符合（后面不用看了）</li><li>如果遇到<code>a[i] = b[i]</code>，目前符合，继续往后看</li></ul> <br></blockquote> <br><p>好了，现在开始一列一列地遍历，去保留满足条件的列，删去不满足条件的列吧！</p> <br><h4><a id="_80"></a>具体做法</h4> <br><p>使用一个布尔数组canSkip，其中canSkip[i]为true则代表第i行可以跳过与上一行的比较。</p> <br><p>第一层循环枚举列，一列一列开始遍历；</p> <br><p>第二层循环枚举行，从第二行开始枚举到最后一行：</p> <br><ul><li>如果当前行被skip则直接跳过当前行</li><li>否则，如果当前行小于上一行，这一列必须移除，退出第二层循环，删除这行（实际是答案数量+1）</li><li>如果遍历到最后一行仍然满足条件，则这一列无需移除，再次遍历这一列，如果下一行大于上一行，则下一行永远不会比上一行字典序大，下次不用遍历“下一行”了，将<code>canSkip[下一行]</code>设置为true。</li></ul> <br><p>特殊的，我们可以记录下一共有多少行可以跳过，当所有行都可以被跳过时，后续再也不用遍历了，直接返回答案即可。</p> <br><h4><a id="_94"></a>时空复杂度</h4> <br><ul><li>时间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml"><br>     <br>      <br>       <br>        <br>         O<br>        <br>        <br>         (<br>        <br>        <br>         s<br>        <br>        <br>         i<br>        <br>        <br>         z<br>        <br>        <br>         e<br>        <br>        <br>         (<br>        <br>        <br>         s<br>        <br>        <br>         t<br>        <br>        <br>         r<br>        <br>        <br>         s<br>        <br>        <br>         )<br>        <br>        <br>         )<br>        <br>       <br>       <br>        O(size(strs))<br>       <br>      <br>     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">ze</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">rs</span><span class="mclose">))</span></span></span></span></span></li><li>空间复杂度<span class="katex--inline"><span class="katex"><span class="katex-mathml"><br>     <br>      <br>       <br>        <br>         O<br>        <br>        <br>         (<br>        <br>        <br>         n<br>        <br>        <br>         )<br>        <br>       <br>       <br>        O(n)<br>       <br>      <br>     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></li></ul> <br><h4><a id="AC_99"></a>AC代码</h4> <br><h5><a id="C_101"></a>C++</h5> <br><pre><code class="prism language-cpp"><span class="token comment">/*<br> * @LastEditTime: 2025-12-21 20:46:33<br> */</span><br><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span><br><span class="token keyword">public</span><span class="token operator">:</span><br>    <span class="token keyword">int</span> <span class="token function">minDeletionSize</span><span class="token punctuation">(</span>vector<span class="token operator"><</span>string<span class="token operator">></span><span class="token operator">&</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> n <span class="token operator">=</span> strs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">int</span> totalSkip <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 第一行不用校验</span><br>        vector<span class="token operator"><</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">canSkip</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><br>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator"><</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>            <span class="token keyword">bool</span> can <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator"><</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token keyword">if</span> <span class="token punctuation">(</span>canSkip<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                    <span class="token keyword">continue</span><span class="token punctuation">;</span><br>                <span class="token punctuation">}</span><br>                <span class="token keyword">if</span> <span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator"><</span> strs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                    can <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><br>                    <span class="token keyword">break</span><span class="token punctuation">;</span><br>                <span class="token punctuation">}</span><br>            <span class="token punctuation">}</span><br>            <span class="token keyword">if</span> <span class="token punctuation">(</span>can<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator"><</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> strs<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&&</span> <span class="token operator">!</span>canSkip<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                        canSkip<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>                        totalSkip<span class="token operator">++</span><span class="token punctuation">;</span><br>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>totalSkip <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><br>                            <span class="token keyword">return</span> ans<span class="token punctuation">;</span><br>                        <span class="token punctuation">}</span><br>                    <span class="token punctuation">}</span><br>                <span class="token punctuation">}</span><br>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span><br>                ans<span class="token operator">++</span><span class="token punctuation">;</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br></code></pre> <br><ul><li>执行用时分布0ms击败100.00%</li><li>消耗内存分布12.57MB击败81.82%</li></ul> <br><blockquote> <br> <p>同步发文于<a href="https://letmefly.blog.csdn.net/article/details/156134471" rel="nofollow">CSDN</a>和我的<a href="https://blog.letmefly.xyz/" rel="nofollow">个人博客</a>，原创不易，转载经作者同意后请附上<a href="https://blog.letmefly.xyz/2025/12/21/LeetCode%200955.%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8FII/" rel="nofollow">原文链接</a>哦~</p> <br> <p>千篇源码题解<a href="https://github.com/LetMeFly666/LeetCode">已开源</a></p> <br></blockquote>