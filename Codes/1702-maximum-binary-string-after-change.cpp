/*
 * @Author: LetMeFly
 * @Date: 2024-04-10 12:10:46
 * @LastEditors: LetMeFly
 * @LastEditTime: 2024-04-10 12:57:42
 */
#ifdef _WIN32
#include "_[1,2]toVector.h"
#endif

/*
00->10->01

000110
100110
110110
110101
110011
111011

错误变换：
0010110001010
1010110001010
1001110001010
1101110001010
1101110001001
1101110001011
1101110000111
1101110001111
1101110011111
1101110111111
1101101111111
1101011111111
1100111111111
1110111111111

正确变换：
0010110001010
0010110001001
0010110000101
0010110000011
0010101000011
0010100100011
0010100010011
0010100001011
0010100000111
0010010000111
0010001000111
0010000100111
0010000010111
0010000001111
0001000001111
0000100001111
0000010001111
0000001001111
0000000101111
0000000011111
1000000011111
1100000011111
1110000011111
1111000011111
1111100011111
1111110011111
1111111011111


错误思路：
1只增不减，先将所有的1移动到最后面变成0000....111
再将前面的0000...变成1111..1110
最终剩下一个0


错误变换：
1100
1011
0111

正确变换：
1100
1110


全1则直接返回，若有0则
最终1111..11011..111
第一个0后面有几个0
最终0的位置就是第一个0的位置往后移几
*/

class Solution {
public:
    string maximumBinaryString(string binary) {
        int cnt0 = count(binary.begin(), binary.end(), '0');
        if (!cnt0) {
            return binary;
        }
        int first0 = binary.find('0');
        return string(first0 + (cnt0 - 1), '1') + '0' + string(binary.size() - (first0 + (cnt0 - 1)) - 1, '1');
    }
};