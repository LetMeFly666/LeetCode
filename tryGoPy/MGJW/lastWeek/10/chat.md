<!--
 * @Author: LetMeFly
 * @Date: 2025-05-18 16:58:47
 * @LastEditors: LetMeFly.xyz
 * @LastEditTime: 2025-05-25 15:18:58
-->
通过文字隐蔽传输信息的方式


---


设计或搜索一套通过两段文字的差异编码的方法，编码结果主要为英文字母即可



---



A可以向B发送两段英文段落，第二段英文段落和第一段英文段落的文本存在差异。

我想设计一套编码机制，基于两段文字的差异进行编码，从而隐蔽传输信息。



---


给你一段文本，将其转为markdown并返回源码
为避免渲染错误，中间不要出现```和连续的空行
如果需要表示源码，则跳过


最长公共子序列
在介绍 Myers 算法之前，我们先来了解一下著名的 最长公共子序列（Longest Common Subsequence，LCS） 问题。我们引用一下 LeetCode 中的问题描述，如下所示。

给定两个字符串 text1 和 text2，返回这两个字符串的最长「公共子序列」的长度。如果不存在「公共子序列」，则返回 0 。
 
一个字符串的「子序列」是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

示例 1：
> 输入：text1 = "CBABAC", text2 = "ABCABBA" 
> 输出：4  
> 解释：最长公共子序列是 "BABA" 或 "CABA" 或 "CBBA" ，它的长度为 4 。
对于 LCS 问题，经典思路是使用动态规划来解决。动态规划的核心思想是 将一个大问题拆分成多个子问题，分别求解各个子问题，基于各个子问题的解推断出大问题的解。与分治、递归相比，动态规划会记录各个子问题的解，避免重复运算，以空间换时间，从而实现对时间复杂度的优化。下面，我们来介绍一下 LCS 的动态规划解法。

假设字符串 
 和 text2 的长度分别为 m 和 n，对此创建一个 m+1 行 n+1 列的二维数组 dp，其中 dp[i][j] 表示 text1[0:i] 和 text2[0:j] 的最长公共子序列的长度。

上述表示中，text1[0:i] 表示 text1 的长度为 i 的前缀，text2[0:j] 表示 text2 的长度为 j 的前缀。

考虑动态规划的边界情况：

当 i = 0 时，text1[0:i] 为空，空字符串和任何字符串的最长公共子序列的长度都是 0，因此对任意 0 ≤ j ≤ n，有 dp[0][j] = 0；
当 j = 0 时，text2[0:j] 为空，同理可得，对任意 0 ≤ i ≤ m，有 dp[i][0] = 0。
因此动态规划的边界情况是：当 i = 0 或 j = 0 时，dp[i][j] = 0。

当 i > 0 且 j > 0 时，考虑 dp[i][j] 的计算：

当 text1[i-1] = text2[j-1] 时，将这两个相同的字符称为公共字符，考虑 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列，再增加一个公共字符即可得到 text1[0:i] 和 text2[0:j] 的最长公共子序列，因此 dp[i][j] = dp[i-1][j-1] + 1。
当 text1[i-1] != text2[j-1] 时，考虑一下两种情况：
情况一：text1[0:i-1] 和 text2[0:j] 的最长公共子序列
情况二：text1[0:i] 和 text2[0:j-1] 的最长公共子序列
对此，计算 text1[0:i] 和 text2[0:j] 的最长公共子序列，应取两项中长度较大的一项，因此 dp[i][j] = max(dp[i-1]][j], dp[i][j-1])。
最终得到如下所示的状态转移方程：

 

下图所示为二维数组 dp[i][j] 的存储内容，大问题的解由子问题的解推导而出，数组整体从左到右，从上到下推导构建。我们在图中使用黄色标识了 text1[i-1] == text2[j-1] 的情况。此时将从左上角相邻的位置取值并加 1；否则，取左边或上边的相邻值中的最大值。整个二维数组中保存的最大值就是 LCS 问题的解。



至此我们计算得到了最长公共子序列的长度，然而在实际情况中，我们倾向于得到最长公共子序列本身。此时，可以借助我们构建的二维数组进行回溯。

回溯的方法是：从二维数组的右下角向左上角遍历，当 i = m+1，j = n+1 时可能会遇到三种情况：

如果 text1[i] = text2[j]，那么向左上角遍历。
如果 text1[i] != text2[j]，判断 dp[i][j] 和 dp[i-1][j] 的值。
如果 dp[i][j] = dp[i-1][j]，则向上遍历；
否则，向左遍历。
由此，我们可以得到如下的遍历路径。



在回溯得到遍历路径之后，我们对路径中向左上角遍历的起始位置进行染色（黄色），即可得到最长公共子序列 CABA，如下图所示。



当然，细心的同学可能会对上述的回溯方法产生疑问：为什么 dp[i][j] = dp[i-1][j] 时向上遍历，而非向左遍历？事实上，如果我们也可以修改回溯方法，得到如下的遍历路径。



同样，我们对路径中向左上角遍历的起始位置进行染色（黄色），即可得到最长公共子序列 BABA，如下图所示。



最小编辑距离
事实上，在特定设定下，最长公共子序列问题可以等价为 最小编辑距离（Minimum Edit Distance，也称 Levenshtein） 问题。

具体设定为：在最小编辑距离问题中，如果编辑操作只有 删除 和 插入，没有 替换 操作，且每个操作的代价是 1，那么从字符串 A 转换成字符串 B 的最小编辑距离就可以转换成如下公式。


以上述 text1 = CBABAC，text2 = ABCABBA 为例，寻找最长公共子序列问题，我们可以视为将 text2 转换成 text1 的最小编辑距离问题。

此时，我们可以将向左遍历的起始位置染成红色，将向上遍历的起始位置染成绿色，如下所示是分别对 CABA 和 BABA 遍历路径的染色图。





这里，我们对已经染色的路径进行编辑规则的定义，如下：

被染成红色的位置，表示在路径中删除原始字符串对应的字符
被染成绿色的位置，表示在路径中插入目标字符串对应的字符
被染成黄色的位置，表示不进行任何编辑编辑操作
此时，我们就可以得到最小编辑距离的实际操作步骤，即 最短编辑脚本（Shortest Edit Script，SES），如下所示。





上面两图的右半部分是两个符合预期的最短编辑脚本。然而，在实际过程中，对某一个原始文本进行编辑得到另一个目标文本，可能会存在非常多的最短编辑脚本。此时我们该如何选择？根据实际经验，我们认为先删除旧内容，后插入新内容，具有更直观的体验。比如：Code Review 的差异比较也都是按照先删除后插入的方式进行展示，如下所示。因此，上述第一种最短编辑脚本更加直观，符合预期。


