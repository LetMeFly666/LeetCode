<!--
 * @Author: LetMeFly
 * @Date: 2025-04-30 19:11:15
 * @LastEditors: LetMeFly.xyz
 * @LastEditTime: 2025-04-30 21:05:20
-->

[TOC]

本周的主要工作是梳理已有工作内容，最大程度上将已有工作梳理清楚，便于鹭乾融入的同时便于结项等时梳理。

# 已有工作梳理总结

已有工作大致概括一下是：搭建远程办公环境、(设计shell提权为窗口的方法、)设计修改数据包的OWA隐蔽传输方式、设计邮件信标的OWA隐蔽传输方式、设计基于时间间隔的webex隐蔽传输方式。

## 修改数据包的OWA隐蔽传输方式

这个可参考周报：`20250308-李腾飞-工作周报-通过邮件两台主机隐蔽传输消息.pdf`（参考周报可能不是最终版本，后续可能会在此基础上进行小改动，但参考周报是最易懂的版本）

通俗的话讲，这个是在干什么呢？就是往收发双方植入一个证书，通过`mitmproxy`修改收发双方主机上的数据包，实现在收发双方看到邮件**完全**正常的同时默默传输隐蔽信息。

### 如何修改数据包

```bash
pip install mitmproxy
mitmproxy --mode transparent  # 禁止python透过防火墙的话，可能需要管理员权限下运行
# 也可以指定只捕获本机数据包：mitmproxy -s main.py --listen-host localhost，这样的话在我笔记本上实测不需要管理员权限
```

浏览器访问`http://mitm.it`下载证书并安装：

+ 双击P12文件，启动导入向导。
+ 选择证书存储位置(这将决定谁将信任该证书——仅当前Windows用户OR机器上的所有人)点击下一步。
+ 再次点击下一步。
+ 将密码留空并点击下一步。
+ 选择“将所有证书放入以下存储”，然后点击浏览，并选择“受信任的根证书颁发机构”。
+ 点击确定和下一步。
+ 点击完成。
+ 在警告对话框中点击是以确认。

这一步中，若是向“当前用户”安装证书，则**不需要管理员权限**。

可以编写简单脚本来验证HTTP包修改成功：

```python
from mitmproxy import http
import logging

logger_url = logging.getLogger('logger_url')
formatter_url = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
for handler in logger_url.handlers[:]:
    if isinstance(handler, logging.StreamHandler):
        logger_url.removeHandler(handler)
logger_url.setLevel(logging.DEBUG)
filehandler_url = logging.FileHandler('url.log')
filehandler_url.setFormatter(formatter_url)
logger_url.addHandler(filehandler_url)

def request(flow: http.HTTPFlow) -> None:
    pass

def response(flow: http.HTTPFlow) -> None:
    # 修改响应
    logger_url.info(flow.request.pretty_url)
    if "web.letmefly.xyz" in flow.request.pretty_url and 'text/html' in flow.response.headers.get('content-type', ''):
        logger_url.info('replace HTML to LMTH')
        flow.response.text = flow.response.text.replace("HTML", "LMTH")
```

设置代理服务器为`localhost:8080`，然后：

```bash
mitmproxy -s modifyPackage.py --listen-host localhost
```

访问[web.letmefly.xyz](https://letmefly.xyz/?From=周报-3day4week)，可以发现“HTML”被替换为了“LMTH”。

### 发送方数据包篡改

以QQ邮箱为例验证该方案的可行性。抓包可发现QQ邮箱发送邮件时，邮件正文在`content__html`字段中，因此可以抓包对此字段做手脚：

```python
from mitmproxy import http
from urllib.parse import parse_qs, urlencode
import logging

logger_url = logging.getLogger('logger_url')
formatter_url = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
for handler in logger_url.handlers[:]:
    if isinstance(handler, logging.StreamHandler):
        logger_url.removeHandler(handler)
logger_url.setLevel(logging.DEBUG)
filehandler_url = logging.FileHandler('url.log')
filehandler_url.setFormatter(formatter_url)
logger_url.addHandler(filehandler_url)


class AddSignatureAddon:
    def request(self, flow: http.HTTPFlow) -> None:
        # 检查目标路径和请求方法
        if flow.request.method == "POST" and "/cgi-bin/compose_send" in flow.request.url:
            # 确保Content-Type正确
            content_type = flow.request.headers.get("Content-Type", "")
            if "application/x-www-form-urlencoded" in content_type:
                # 解析原始表单数据
                try:
                    parsed_data = parse_qs(flow.request.content.decode("utf-8"))
                except Exception as e:
                    logger_url(f"解析表单数据失败: {e}")
                    return

                # 修改content__html字段
                if "content__html" in parsed_data and parsed_data["content__html"]:
                    original_content = parsed_data["content__html"][0]
                    new_content = original_content + "*******计划有变*******"
                    parsed_data["content__html"][0] = new_content

                    # 重新编码并更新请求内容
                    updated_content = urlencode(parsed_data, doseq=True).encode("utf-8")
                    flow.request.content = updated_content
                    logger_url("成功添加签名！")
                else:
                    logger_url("未找到content__html字段")

addons = [AddSignatureAddon()]
```

设置代理服务器为`localhost:8080`，然后：

```bash
mitmproxy -s modifyPackage.py --listen-host localhost
```

发送邮件，可以看到网页端没有任何异常，浏览器控制台也一切正常。

但是实际发出的邮件就不一样了，多了一段`*******签名*******`

### 接收方数据包篡改

接收方篡改无需分析HTML格式，只需要正则匹配提取密文即可。接收方篡改有个注意事项，邮件返回内容是以gb18030格式编码的。所以默认的UTF-8很容易乱码。


```python
def response(self, flow: http.HTTPFlow) -> None:
    if flow.request.method == 'GET' and '/cgi-bin/readmail' in flow.request.url:
        if "text/html" not in flow.response.headers.get("Content-Type", ""):
            return
        try:
            html_content = flow.response.content.decode("gb18030")
        except UnicodeDecodeError:
            logger.info('解码失败：可能不是GB18030编码')
        match = re.search(r'\*{7}(.*?)\*{7}', html_content)
        if match:
            signature = match.group(1)
            logger.info(f"提取到签名：{signature}")
            html_content = re.sub(r'\*{7}.*?\*{7}', '', html_content)
        flow.response.content = html_content.encode("gb18030")
        flow.response.headers["Content-Length"] = str(len(flow.response.content))
```

### 另外的工作

上面是为了方便理解所以描述的简单版本，后续周报中也进行了一些优化，如“将隐蔽传输的消息加密和解密”、“使用HTML格式隐藏额外元素”等。

还有一些小脚本，可用来演示接收和发送等。


发送方demo：

```python
while True:
    data = input('想隐蔽传输的信息：')
    with open('letsender', 'w', encoding='utf-8') as f:
        f.write(data)
```

接收方demo：

```python
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import os

FILE_PATH = 'letreceiver'

if not os.path.exists(FILE_PATH):
    os.system(f'echo > {FILE_PATH}')

class FileChangeHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if event.src_path.endswith(FILE_PATH):
            print(f"File {FILE_PATH} has been modified. Reading new content...")
            self.read_file_content()

    def read_file_content(self):
        try:
            with open(FILE_PATH, 'r', encoding='utf-8') as file:
                content = file.read()
                print("New content:")
                print(content)
        except Exception as e:
            print(f"Error reading file: {e}")

if __name__ == "__main__":
    # 创建事件处理器和观察者
    event_handler = FileChangeHandler()
    observer = Observer()
    observer.schedule(event_handler, path='.', recursive=False)

    # 启动观察者
    observer.start()
    print(f"Started watching {FILE_PATH} for changes...")

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()

    observer.join()
```

演示视频：[nextcloud-通过邮件传递隐藏信息-ltf-20250308.flv](https://nextcloud.bupt-narc.cn/f/313275)  只有内网能访问到。

### 特点

代理是在系统层面的，浏览器即使抓包也看不到隐蔽传输的内容。

## 设计邮件信标的OWA隐蔽传输方式

这个可参考周报：`20250413-李腾飞-两个邮件隐蔽传输信道实现.pdf`

## 设计基于时间间隔的webex隐蔽传输方式

这个可参考周报：`20250427-李腾飞-信标长度确定+webex隐蔽传输信道设计_v1.pdf`
