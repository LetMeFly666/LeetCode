<!--
 * @Author: LetMeFly
 * @Date: 2025-03-06 10:23:41
 * @LastEditors: LetMeFly.xyz
 * @LastEditTime: 2025-03-06 17:40:32
-->
<!--
 * @Author: LetMeFly
 * @Date: 2025-02-28 09:33:07
 * @LastEditors: LetMeFly.xyz
 * @LastEditTime: 2025-03-06 10:26:26
-->
> [!CAUTION]
> 
> 上周组会没带电脑，不是因为“有高年级的架子”(完全没有这种想法)，更不是因为不尊重老师(如果不是因为上周组会，许老师开会我还真有可能不带电脑)。
>
> 而是没有意识到组会带电脑的重要性，因为我当时想的是“不带电脑就能完成的事情为什么要费劲带电脑”。

# 已有隐蔽传输方式

1. 通过shell连接到Windows并“提权”执行带有图形界面的程序
2. Windows自带远程连接-通过键盘大小写来实现零一传输

    远程连接的键盘大小写锁定和本机较为独立，更不能实时相互反映

    但是本机键盘在默认状态下大小写/数字锁定灯亮的情况下，若经过自然锁屏则对应指示灯不熄灭，一旦远程连接建立则立刻熄灭

3. 

# 改包

```bash
pip install mitmproxy
mitmproxy --mode transparent  # 禁止python透过防火墙的话，可能需要管理员权限下运行
# 也可以指定只捕获本机数据包：mitmproxy -s main.py --listen-host localhost
```

浏览器访问`http://mitm.it`下载证书并安装：

+ 双击P12文件，启动导入向导。
+ 选择证书存储位置(这将决定谁将信任该证书——仅当前Windows用户OR机器上的所有人)点击下一步。
+ 再次点击下一步。
+ 将密码留空并点击下一步。
+ 选择“将所有证书放入以下存储”，然后点击浏览，并选择“受信任的根证书颁发机构”。
+ 点击确定和下一步。
+ 点击完成。
+ 在警告对话框中点击是以确认。

若想编写脚本：

```python
from mitmproxy import http
import logging

logger_url = logging.getLogger('logger_url')
formatter_url = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
for handler in logger_url.handlers[:]:
    if isinstance(handler, logging.StreamHandler):
        logger_url.removeHandler(handler)
logger_url.setLevel(logging.DEBUG)
filehandler_url = logging.FileHandler('url.log')
filehandler_url.setFormatter(formatter_url)
logger_url.addHandler(filehandler_url)


logger_text = logging.getLogger('logger_text')
formatter_text = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
for handler in logger_text.handlers[:]:
    if isinstance(handler, logging.StreamHandler):
        logger_text.removeHandler(handler)
logger_text.setLevel(logging.DEBUG)
filehandler_text = logging.FileHandler('text.log')
filehandler_text.setFormatter(formatter_text)
logger_text.addHandler(filehandler_text)


def request(flow: http.HTTPFlow) -> None:
    # # 修改请求
    # if "letmefly.xyz" in flow.request.pretty_url:
    #     flow.request.headers["User-Agent"] = "Modified-Agent"
    pass

def response(flow: http.HTTPFlow) -> None:
    # 修改响应
    logger_url.info(flow.request.pretty_url)
    if "web.letmefly.xyz" in flow.request.pretty_url and 'text/html' in flow.response.headers.get('content-type', ''):
    # if flow.request.pretty_url == 'https://web.letmefly.xyz/':
        logger_url.info('replace HTML to LMTH')
        # logger_text.info(flow.response.text)
        flow.response.text = flow.response.text.replace("HTML", "LMTH")
```

设置代理服务器为`localhost:8080`，然后：

```bash
mitmproxy -s modifyPackage.py --listen-host localhost
```

结果发现：请求替换成功！

代理前：

![代理前](pics/beforeChange.jpg)

代理后：

![代理后](pics/afterchange.jpg)

由于具有主机操作权限，所以主机信任mitm颁发的证书，浏览器也没有任何“不安全警告”，页面就这么悄无声息地被替换了。

# 邮件发送

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from password import sender_password

# 邮件配置
smtp_server = 'smtp.qq.com'
smtp_port = 587
sender_email = 'LetMeFly666@qq.com'
sender_password = sender_password
receiver_email = 'Tisfy@qq.com'

# 创建邮件内容
subject = '这是一封正常邮件'
body = '今天中午吃饭吗'
msg = MIMEMultipart()
msg['From'] = sender_email
msg['To'] = receiver_email
msg['Subject'] = subject
msg.attach(MIMEText(body, 'plain'))

# 发送邮件
try:
    server = smtplib.SMTP(smtp_server, smtp_port)
    server.starttls()
    server.login(sender_email, sender_password)
    server.sendmail(sender_email, receiver_email, msg.as_string())
    print("邮件发送成功")
except Exception as e:
    print(f"邮件发送失败: {e}")
finally:
    server.quit()
```

![发送成功](pics/sendok.jpg)

# 邮件接收

```python
import imaplib
import email
from email.header import decode_header
from password import sender_password

# 邮件配置
imap_server = 'imap.qq.com'
imap_port = 993
email_address = 'tf.li@foxmail.com'
email_password = sender_password

# 连接到IMAP服务器
try:
    mail = imaplib.IMAP4_SSL(imap_server, imap_port)
    mail.login(email_address, email_password)
    mail.select('inbox')  # 选择收件箱

    # 搜索邮件
    status, messages = mail.search(None, 'ALL')  # 获取所有邮件
    if status != 'OK':
        print("没有找到邮件")
        exit()

    # 获取邮件列表
    mail_ids = messages[0].split()
    latest_mail_id = mail_ids[-1]  # 获取最新的一封邮件

    # 获取邮件内容
    status, msg_data = mail.fetch(latest_mail_id, '(RFC822)')
    if status != 'OK':
        print("无法获取邮件内容")
        exit()

    # 解析邮件内容
    for response_part in msg_data:
        if isinstance(response_part, tuple):
            msg = email.message_from_bytes(response_part[1])
            subject, encoding = decode_header(msg['Subject'])[0]
            if isinstance(subject, bytes):
                subject = subject.decode(encoding if encoding else 'utf-8')
            from_ = msg.get('From')
            print(f"主题: {subject}")
            print(f"发件人: {from_}")

            # 获取邮件正文
            if msg.is_multipart():
                for part in msg.walk():
                    content_type = part.get_content_type()
                    content_disposition = str(part.get("Content-Disposition"))
                    if content_type == 'text/plain' and 'attachment' not in content_disposition:
                        body = part.get_payload(decode=True).decode()
                        print(f"正文: {body}")
            else:
                body = msg.get_payload(decode=True).decode()
                print(f"正文: {body}")

except Exception as e:
    print(f"接收邮件失败: {e}")
finally:
    mail.logout()
```

> [!CAUTION]
> 
> 在邮件接收还未认证的时候，忽然想到mitmproxy是不是只能抓HTTP(s)不能抓SMTP之类的
>
> 发了个邮件果然没抓到。。。

# 客户端发送邮件抓包

那就不模拟了，直接使用客户端发吧，这样也更真实一点。

以QQ邮件为例，发送邮件时会向`https://mail.qq.com/cgi-bin/compose_send?sid=xxxxx`发送一个POST请求，表单数据包括：

```
mailtype: 
dockey: 
bigattachcontent: 
xxxxxxxxxxx: xxxxxxxxx
sid: xxxxx
bigattachcnt: 
exstore: 
from_s: cnew
swap: 
signtype: 
newwin: 
verifykey: 
stationeryCount: 
to: "Let"<Tisfy@qq.com>
swap3: 
cc: 
subject: 今日指令
content__html: 一切正常，和昨天一样
sendmailname: tisfy@foxmail.com
savesendbox: 1
swap2: 
transattach: 
SrcMailCharset: 
xqqstyle: 
mailbgmusic: 
actiontype: send
priority: 
sendname: LetMeFly
acctid: 0 
ReAndFw: 
separatedcopy: false
fmailid: xxxx-xxxxxx
ReAndFwMailid: 
cattachelist: 
upfilelist: 
rsturl: 
fileidlist: 
t: backgroundsend
verifycode: 
verifycode_cn: 
s: comm
from: 
hitaddrbook: 0
selfdefinestation: -1
backurl: 
noatcp: 
domaincheck: 0
cgitm: 1741223758403
clitm: 1741223762955
comtm: 1741223962691
logattcnt: 0
logattsize: 0
logattmethod: 
timezone: 28800
timezone_dst: 0
resp_charset: UTF8
bgsend: 1
```

消息内容在`content__html`字段中。又觉得可行了起来。

# 客户端接收邮件抓包

当用户读取具体邮件时，会请求：`https://mail.qq.com/cgi-bin/readmail?folderid=1&folderkey=1&t=readmail&mailid=xxxx~xxx&mode=pre&maxage=3600&base=11.08&ver=13964&sid=xxxx`。

请求头之类的不重要，我们只要匹配这个url就行。

可以看到，响应体里就是一个HTML，简化后如下：

```html
<!DOCTYPE html>
<html>
    <head>
        <title>今日指令 - QQ邮箱</title>
        <!-- 此处省略一堆script、style、meta -->
    </head>
    <body context="邮件ID" module="qmReadMail" md="md" mu="mu">
        <div class="mailcontainer" id="qqmail_mailcontainer">
            <div id="mainmail" style="position:relative;z-index:1;margin-bottom:12px;">
                <div id="contentDiv" onmouseover="getTop().stopPropagation(event);" onClick="getTop().preSwapLink(event, 'html', 'ZC0006_StHNHHSMYOYuV2cAGA~jBf3');" style="position:relative;font-size:14px;height:auto;padding:15px 15px 10px 15px;z-index:1;zoom:1;line-height:1.7;" class="body">
                    <div id="qm_con_body">
                        <div id="mailContentContainer" onClick="getTop().previewContentImage(event, '')" onMousemove="getTop().contentImgMouseOver(event, '')" onMouseout="getTop().contentImgMouseOut(event, '')" class="qmbox qm_con_body_content qqmail_webmail_only" style="opacity: 0">
                            <div id="mailcontent_image_operator" onMouseover="getTop().contentOperatorMouseOver(event)" onClick="getTop().handleOperatorClick(event)" style="position: fixed; left: 0; top: 0;">
                                <div class="operator-item" title="图片翻译" id="operator-item-translate" operate="translate">
                                    <div class="item-inner" operate="translate"></div>
                                </div>
                                <div class="operator-item" title="文字提取" id="operator-item-extract" operate="extract">
                                    <div class="item-inner" operate="extract"></div>
                                </div>
                                <div class="operator-item" title="导出表格" id="operator-item-form" operate="form">
                                    <div class="item-inner" operate="form"></div>
                                </div>
                                <div class="operator-item" title="下载图片" id="operator-item-download" operate="download">
                                    <div class="item-inner" operate="download"></div>
                                </div>
                            </div>
                            <script>
                                document.addEventListener('DOMContentLoaded', function() {
                                    getTop().handleScanContentImage('ZC0006_StHNHHSMYOYuV2cAGA~jBf3');
                                })
                            </script>
                            <style>
                                /* 邮件内部图片支持调起预览。 */
                                img[image-inside-content='1'] {
                                    cursor: pointer;
                                }
                            </style>
                            一切正常，和昨天一样<style type="text/css">
                                .qmbox style, .qmbox script, .qmbox head, .qmbox link, .qmbox meta {
                                    display: none !important;
                                }
                            </style>
                        </div>
                    </div>
                    <!-- -->
                    <style>
                        #mailContentContainer .txt {
                            height: auto;
                        }
                    </style>
                </div>
            </div>
        </div>
    </body>
</html>
<!-- 此处省略一堆script -->
```

发送的邮件主体就出现在简化后的HTML的第38行。

在研究期间还看到了一个有点意思的图，mark一下：

![stream](pics/stream.png)

# 消息验证 - 发送邮件时后台篡改

```python
from mitmproxy import http
from urllib.parse import parse_qs, urlencode
import logging

logger_url = logging.getLogger('logger_url')
formatter_url = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
for handler in logger_url.handlers[:]:
    if isinstance(handler, logging.StreamHandler):
        logger_url.removeHandler(handler)
logger_url.setLevel(logging.DEBUG)
filehandler_url = logging.FileHandler('url.log')
filehandler_url.setFormatter(formatter_url)
logger_url.addHandler(filehandler_url)


class AddSignatureAddon:
    def request(self, flow: http.HTTPFlow) -> None:
        # 检查目标路径和请求方法
        if flow.request.method == "POST" and "/cgi-bin/compose_send" in flow.request.url:
            # 确保Content-Type正确
            content_type = flow.request.headers.get("Content-Type", "")
            if "application/x-www-form-urlencoded" in content_type:
                # 解析原始表单数据
                try:
                    parsed_data = parse_qs(flow.request.content.decode("utf-8"))
                except Exception as e:
                    logger_url(f"解析表单数据失败: {e}")
                    return

                # 修改content__html字段
                if "content__html" in parsed_data and parsed_data["content__html"]:
                    original_content = parsed_data["content__html"][0]
                    new_content = original_content + "*******计划有变*******"
                    parsed_data["content__html"][0] = new_content

                    # 重新编码并更新请求内容
                    updated_content = urlencode(parsed_data, doseq=True).encode("utf-8")
                    flow.request.content = updated_content
                    logger_url("成功添加签名！")
                else:
                    logger_url("未找到content__html字段")

addons = [AddSignatureAddon()]
```

设置代理服务器为`localhost:8080`，然后：

```bash
mitmproxy -s modifyPackage.py --listen-host localhost
```

发送邮件，可以看到网页端没有任何异常，浏览器控制台也一切正常。

但是实际发出的邮件就不一样了，多了一段`*******签名*******`

![实际邮件](pics/realEmail.png)
