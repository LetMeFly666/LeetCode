已知有如下遍历方式，我想找到一种方式满足：

+ 我有一个012序列（0代表左上，1代表左，2代表上）
+ 我想生成两个字符串text1和text2，使得使用如下算法进行遍历得到的结果是我的012序列。

遍历方式如下：

首先回忆DP数组和方向是怎么走的

```
dp[i][j] = {
    dp[i-1][j-1] + 1,              if text1[i-1] == text2[j-1]
    max(dp[i-1][j], dp[i][j-1]),   if text1[i-1] != text2[j-1]
}
```

回溯的方法是：从二维数组的右下角向左上角遍历，当 i = m+1，j = n+1 时可能会遇到三种情况：

1. 如果 text1[i] = text2[j]，那么向左上角遍历。
2. 如果 text1[i] != text2[j]，判断 dp[i][j] 和 dp[i-1][j] 的值。
   - 如果 dp[i][j] = dp[i-1][j]，则向上遍历；
   - 否则，向左遍历。

由此，我们可以得到如下的遍历路径。

![Backtracking Path 1](pics/002.png)

在回溯得到遍历路径之后，我们对路径中向左上角遍历的起始位置进行染色（黄色），即可得到最长公共子序列 CABA。

![LCS CABA](pics/003.png)
